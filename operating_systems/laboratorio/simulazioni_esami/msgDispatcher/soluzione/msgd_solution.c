// msgDispatcher

// ---------------------------------------------------------------------------------------------------- //

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <signal.h>
#include <pthread.h>
#include <errno.h>
#include <sys/wait.h>

// ---------------------------------------------------------------------------------------------------- //

#define MAX_CHD  5                 // Max children allowed
#define MAX_CMD 20                 // Max length of the commands (stdin)
#define MAX_MSG 50                 // Max length of the message

// ---------------------------------------------------------------------------------------------------- //

int extern errno;                  // errno external variable
pthread_t t_id;                    // id of the thread that will be created
int signalNumber;                  // received signal number
int fd[MAX_CHD][2];                // pipes for each child
int currentChild = 0;              // current number of active children
FILE *logFile;                     // log file pointer

pid_t children[MAX_CHD];           // pid for each children
char msg[MAX_MSG];                 // msg to be sent to the children
char bufferCommand[MAX_CMD] = {0}; // buffer to hold the input strings

// ---------------------------------------------------------------------------------------------------- //

// handler for the thread, that will output data on the logFile
void *threadHandler(void *param){
    
    fprintf(logFile,"\033[0;31m[THREAD] I'm a new thread generated by signal %d\033[0m\n",*(int *)param);
    fprintf(logFile,"[THREAD] Sending message to children\n");
    
    // send a message to each child using the pipe
    for(int i = 0; i<currentChild; i++){
        memset(msg, 0, MAX_MSG*sizeof(char));                                  // empty msg variable
        sprintf(msg,"To Child %d PID %d: %s", i, children[i], bufferCommand); // set msg variable
        // sprintf(msg,"%d|%d|%s", i, children[i], bufferCommand); // set msg variable
        fprintf(stderr,"\033[0;32m[THREAD] msg='%s'\033[0m\n", msg);          // dump msg to stder
        write(fd[i][1], msg, strlen(msg));                                    // write msg to i-th pipe
        close(fd[i][1]);                                                      // close pipe
    };
    // reset children counter (as they terminate after receiving the msg)
    currentChild=0;

    fprintf(logFile,"[THREAD] children reset\n"); 
    fprintf(logFile,"[THREAD] Terminating thread\n");
}

// ---------------------------------------------------------------------------------------------------- //

// signal handler
pthread_attr_t attr;
void sigHandler(int signo, siginfo_t * info, void * empty){
    // send the signal number to the thread
    signalNumber = signo;
    pthread_create(&t_id,&attr, threadHandler, (void *)&signalNumber); // create thread passing signalNumber
}

// handler to close logFile upon SIGINT / CTRL+C
void quitHandler(int signo){
    fclose(logFile);          // close the log file
    kill(-getpid(), SIGTERM); // terminate hanging children
    while(wait(NULL)>0);      // wait for their termination
    printf("\n");
    exit(0);
}

// ---------------------------------------------------------------------------------------------------- //

int main(int argc, char ** argv){

    // initialise sigaction
    struct sigaction sa;
    sa.sa_sigaction = sigHandler;
    sigemptyset(&sa.sa_mask);

    // init log file
    logFile = fopen("/tmp/log.txt","w");
    
    // initilise attribute for threads
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    // set up the various signals handlers
    sigaction(SIGUSR1, &sa, NULL);
    sigaction(SIGUSR2, &sa, NULL);
    signal(SIGINT, quitHandler);
    signal(SIGTERM, SIG_IGN);

    printf("\033[0;32m[MAIN] main PID is %d \033[0m\n",getpid()); // dump infos

    char command[MAX_CMD]; // temporary buffer for input
    int r, intCmd;
    
    // idle:
    while(1) {

        r = read(STDIN_FILENO, command, MAX_CMD-1); // read from stdin
        
        // if signal generated then "read" is interrupted
        if (errno == EINTR){
            // reset errno and continue
            errno = 0;
            continue;
        };
        command[r-1] = 0; // terminate string (change '\n' with '\0')
        
        // possibly convert command to int
        intCmd = atoi(command);
        if (intCmd > 0){ // it is a positive integer
            if (currentChild < MAX_CHD){            // if there's room for more children...
                pipe(fd[currentChild]);             // ...init the pipe for the new child...
                children[currentChild] = fork();    // ...and create it saving its pid
                if (children[currentChild]  == 0) { // * CHILD *
                    close(fd[currentChild][1]);     // . close writing side of pipe
                    break;                          // . exit from while-loop and go on
                };
                // * PARENT *
                // (this part is reached only by parent)
                close(fd[currentChild][0]);         // . close reading side of pipe
                currentChild++;                     // . increase counter of children
            } else {
                fprintf(stderr,"\033[0;32m[MAIN] Too many children. Send msg to free them \033[0m\n"); // error: too many children
            };
        } else { // if it was not a positive integer it is seen as a string message
            memset(bufferCommand, 0, MAX_CMD*sizeof(char)); // empty bufferCommand variable
            strncpy(bufferCommand, command, r);            // save the message to the buffer
            bufferCommand[r]=0;
            fprintf(stderr, "\033[0;32m[MAIN] Msg '%s' saved \033[0m\n", bufferCommand);
        }
    }

    // * CHILD *
    // (this part is outside the while-loop and it's reached only by children)

    signal(SIGTERM, SIG_DFL); // reset the sighandler to its default handler
    printf("\033[0;33m[CHD] I'm a new child with PID %d, and I'm waiting for msg from my father\033[0m\n", getpid());
    memset(msg, 0, MAX_MSG*sizeof(char));    // empty msg variable
    read(fd[currentChild][0],&msg,MAX_MSG); // read message from pipe
    printf("\033[0;33m[CHD] I received the following message: '%s' \033[0m\n", msg);
    close(fd[currentChild][0]);             // close reading side of pipe
    exit(0);
}

// ---------------------------------------------------------------------------------------------------- //